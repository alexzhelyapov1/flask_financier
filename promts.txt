Напиши на python, используя SQLite, API для работы с базой данных для приложения. Это API должно предоставлять необходимые функции и проверки для работы с базой данных, и полностью отделять работу с базой данных от остального приложения.
База данных должна содержать следующие таблицы:
1) Таблица Users.
Поля:
    - user_id - уникальный id пользователя
    - admin - является ли пользователь администратором
    - login - уникальный логин
    - password - храним пароль в кэшированном виде
    - friends - список id других пользователей
    - description - дополнительная информация, просто текст
В таблицы Users все поля являются обязательными, кроме description. 

2) Таблица Spheres.
Поля:
    - sphere_id - уникальный id сферы
    - name
    - description
    - user_id - id владельца записи
    - user_read_ids - id пользователей, которые могут видеть эту запись
    - user_edit_ids - id пользователей, которые могут менять или удалять эту запись
В таблицы Spheres все поля являются обязательными, кроме description.

3) Таблица Locations.
Поля:
    - location_id - уникальный id локации (например банка или счета)
    - name
    - description
    - user_id - id владельца записи
    - user_read_ids - id пользователей, которые могут видеть эту запись
    - user_edit_ids - id пользователей, которые могут менять или удалять эту запись
В таблицы Locations все поля являются обязательными, кроме description.

4) Таблица Accounting.
Поля:
    - accounting_id - id события. Может повторяться только если тип операции is_transfer.
    - user_id - id владельца записи
    - user_read_ids - id пользователей, которые могут видеть эту запись
    - user_edit_ids - id пользователей, которые могут менять или удалять эту запись
    - operation_type - тип операции, может принимать одно из трех значений: "Income", "Spend". Может быть объявлено численными константами для лучшей скорости.
    - is_transfer - bool, является ли эта операция частью transfer
    - sphere_id
    - location_id
    - sum - сумма в рублях, может быть нецелым
    - description
    - date
В таблице Accounting обязательными являются accounting_id, operation_type, location_id, sum, date. Date должна автоматом выставляться текущей датой-временем, если не передается в API.

Код должен быть защищен от sql инъекций. Операция перевода (transfer) реализуется как 2 операции: Spend + Income. Существуют transfer между сферами или между локациями. Реализуй необходимую логику проверок в API базы данных.

Какие проверки должны быть реализованы:
1) Администратор видит и может все.
2) Добавлять пользователей может только система или администратор.
3) Владелец записи может делать с записью все.
4) Владелец записи может добавить только своих друзей в поля user_read_ids, user_edit_ids.
5) Если приходит тип операции transfer (из одной сферы в другую, либо из одной локации в другую) система создает в таблице 2 записи в одной таблице Accounting с одинаковым accounting_id, но одна операция Spend, другая Income. Это единственный сценарий в котором допустимо, что одно из sphere_id или location_id может быть пустым. В остальных случаях они всегда не пусты.
6) Дата сохраняется полностью, включая время. Если дата не передается в API, устанавливается значение now() (GMT+3)
7) Обычные события Spend или Income добавляются в таблицу Accounting с уникальным accounting_id.

Это должен быть 1 файл db_api.py. Позже мы сделаем отдельный файл для заполнения таблицы тестовыми примерам, сейчас это не надо. В API должно сейчас присутствовать создание таблиц, создание, изменение и удаление записей для каждой таблицы. Тумаю функционал и целевое использование тебе в целом понятно. Реализуй этот код и пришли мне. Может добавлять короткие описания у функций, но короткие, не надо писать полноценную документацию.




---


Отлично, теперь напиши для этого приложения простой фронтенд используя python Flask. Какие формы должны присутствовать:
1) Главная страница титульник. Просто с текстом что это система для финансового учета. В углу вход\регистрация.
2) Стандартная форма входа и регистрации. После входа пользователь при попытке обращения к базе данных всегда скрыто отправляет свой id.
3) Для пользователя должны быть формы для редактирования и добавления сфер\локаций.
4) Должна быть форма для просмотра хронологии по сферам, а также другая по локациям.
5) Должна быть кнопка добавления новой записи с вариантами Income, Spend, Transfer. Пользователь не должен видеть, что Transfer реализуется как Income + Spend.
6) Должна быть страница, на которой общая сводка: общая сумма денег и цветной график распределения общей суммы по сферам и по локациям с подписями суммы и в скобочках процента от общей суммы.
7) Администратор должен иметь полный доступ, он может выбрать ID пользователя и просмотреть\редактировать всю информацию по нему, как и сам пользователь. Т.е. администратор просто выбирает пользователя и видит то же самое, что и сам пользователь.





---



**Роль:** Ты — опытный full-stack разработчик и системный архитектор. Твоя задача — спроектировать и написать код для бэкенда нового мультиплатформенного приложения, мигрируя с прототипа на Flask. Ты пишешь чистый, эффективный, идиоматичный и легко поддерживаемый код. Твой код должен быть самодокументируемым, поэтому комментарии используй по минимуму, только для объяснения сложной или неочевидной логики.

**Проект:** Создание бэкенда для мультиплатформенного приложения "Финансист" (учет личных финансов, планирование, заметки). Бэкенд будет представлять собой REST API, предназначенный для взаимодействия с клиентским приложением на Flutter.

**Контекст:** Мне предоставлен исходный код прототипа, написанного на Flask, с использованием SQLite и шаблонов Jinja2. Этот код следует рассматривать как **спецификацию функциональных требований**, а не как пример для подражания в реализации. Твоя задача — полностью переосмыслить и написать проект с нуля на современном и более подходящем стеке.

**Технологический стек:**

*   **Бэкенд:** Python, FastAPI, SQLAlchemy (с асинхронным драйвером), Pydantic.
*   **База данных:** Проектирование с прицелом на **PostgreSQL**. Для управления миграциями схемы БД используй **Alembic**.
*   **Аутентификация:** Stateless, на основе **JWT-токенов** (OAuth2 Password Flow).
*   **Окружение:** Код должен быть готов к контейнеризации с помощью Docker.

---

### Ключевые архитектурные инструкции и требования

При разработке API ты должен учесть следующие моменты, которые исправят недостатки прототипа и заложат правильный фундамент:

**1. Проектирование Базы Данных (SQLAlchemy & Alembic):**

*   **Модели данных:** Создай декларативные модели SQLAlchemy для всех сущностей: `User`, `Sphere`, `Location`, `AccountingRecord`.
*   **Отказ от "списков в строке":** Самый важный пункт миграции. В старом коде поля `friends`, `user_read_ids`, `user_edit_ids` хранятся как строки с ID через запятую. Это антипаттерн. Ты должен реализовать это через правильные реляционные связи:
    *   **Друзья (`friends`):** Реализуй как **many-to-many** связь таблицы `User` с самой собой через ассоциативную таблицу (`user_friends_association`).
    *   **Права доступа (`user_read_ids`, `user_edit_ids`):** Для `Sphere` и `Location` реализуй две отдельные **many-to-many** связи с `User` через ассоциативные таблицы (например, `sphere_readers_association`, `sphere_editors_association`). Это обеспечит целостность данных и упростит запросы.
*   **Типы данных:** Используй корректные типы данных, подходящие для PostgreSQL (например, `TIMESTAMP(timezone=True)` для дат, `Numeric` для финансовых сумм).
*   **Миграции:** С самого начала инициализируй Alembic и создавай миграции для каждого изменения схемы.

**2. Структура API (FastAPI & Pydantic):**

*   **Модульность:** Раздели API на логические модули с помощью `APIRouter`. Как минимум: `auth.py`, `users.py`, `spheres.py`, `locations.py`, `records.py`.
*   **Схемы Pydantic:** Для каждой модели SQLAlchemy создай соответствующие Pydantic-схемы для валидации и сериализации. Используй паттерн `ModelBase`, `ModelCreate`, `ModelUpdate`, `ModelRead`. Это обеспечит строгую типизацию и автоматическую валидацию данных на входе и выходе.
*   **Dependency Injection:** Активно используй систему зависимостей (`Depends`) FastAPI для:
    *   Получения асинхронной сессии БД (`get_db_session`).
    *   Получения текущего аутентифицированного пользователя (`get_current_user`).

**3. Аутентификация и Авторизация:**

*   **JWT:** Реализуй эндпоинт `/token` (OAuth2 Password Flow), который принимает `username` и `password` и возвращает `access_token` и `token_type`.
*   **Защита эндпоинтов:** Все эндпоинты, требующие аутентификации, должны быть защищены зависимостью `Depends(get_current_user)`.
*   **Проверка прав:** Логику из `_check_ownership_and_permissions` старого `db_api.py` нужно перенести. Создай переиспользуемую зависимость или хелпер-функцию, которая будет проверять, является ли текущий пользователь владельцем ресурса, имеет ли он права на чтение/редактирование. Это должно вызываться внутри каждого эндпоинта, работающего с конкретным ресурсом (например, при получении, обновлении или удалении сферы).
*   **Функция "Админ видит как...":** Реализуй эту возможность не через сессии, а через специальный параметр в запросе, доступный только админам. Например, `GET /api/v1/spheres?as_user_id={user_id}`. Внутри зависимости `get_current_user` должна быть логика: если запрашивающий — админ и передан параметр `as_user_id`, то для данного запроса "действующим" пользователем становится указанный юзер.

**4. Проектирование Эндпоинтов:**

*   **RESTful принципы:** Следуй принципам REST. Используй правильные HTTP-методы (`GET`, `POST`, `PUT`/`PATCH`, `DELETE`) и статусы ответа (200, 201, 204, 400, 401, 403, 404).
*   **Бизнес-логика:** Сложные операции, как создание транзакции-перевода (которая в старом коде создает две записи в БД), должны быть атомарными и реализованы в рамках одной транзакции БД.
*   **Эндпоинт для дашборда:** Создай отдельный эндпоинт `GET /dashboard`, который будет агрегировать данные (общий баланс, суммы по сферам и локациям) на сервере и отдавать их в готовом для отображения виде. Это эффективнее, чем заставлять клиентское приложение запрашивать все записи и считать на своей стороне.

---

### План Действий по Реализации

Ты должен следовать этому плану, предоставляя полный и готовый к запуску код на каждом этапе.

**Этап 1: Фундамент проекта**
1.  Создай структуру проекта (папки для моделей, схем, роутеров, сервисов/crud).
2.  Настрой `requirements.txt` со всеми зависимостями.
3.  Определи модели SQLAlchemy (`User`, `Sphere`, `Location`, `AccountingRecord`) с правильными many-to-many связями.
4.  Инициализируй Alembic и создай первую миграцию, генерирующую все таблицы.
5.  Реализуй базовую конфигурацию FastAPI.
6.  Создай роутер `auth` с эндпоинтом `/token` и хелперами для создания и верификации JWT. Реализуй зависимость `get_current_user`.
7.  Создай роутер `users` с эндпоинтом для регистрации нового пользователя (`POST /users/register`) и получения информации о себе (`GET /users/me`).

**Этап 2: CRUD для Сфер и Локаций**
1.  Создай CRUD-функции (Create, Read, Update, Delete) для `Sphere` и `Location`.
2.  Реализуй роутеры `spheres.py` и `locations.py` со стандартными REST-эндпоинтами:
    *   `POST /`: создание новой сущности.
    *   `GET /`: получение списка всех доступных (своих и расшаренных) сущностей.
    *   `GET /{id}`: получение одной сущности по ID.
    *   `PUT /{id}`: полное обновление сущности.
    *   `DELETE /{id}`: удаление.
3.  В каждый эндпоинт, работающий с `{id}`, добавь логику проверки прав доступа (владение, права на чтение/редактирование).

**Этап 3: Основная бизнес-логика (Финансовые операции)**
1.  Создай CRUD-функции для `AccountingRecord`.
2.  Реализуй роутер `records.py`.
3.  Создай эндпоинт `POST /records` для добавления операции. Он должен принимать Pydantic-схему, которая может описывать "Доход", "Расход" или "Перевод". Внутри этого эндпоинта должна быть логика:
    *   Для Дохода/Расхода создается одна запись.
    *   Для Перевода (между счетами или сферами) атомарно создаются две записи в БД (списание и зачисление) с одинаковым `accounting_id` (или аналогичным полем для связи).
4.  Реализуй эндпоинт `GET /records` для получения истории операций с пагинацией.

**Этап 4: Агрегация данных и Администрирование**
1.  Создай эндпоинт `GET /dashboard`, который будет считать и возвращать сводную информацию (общий баланс, балансы по локациям и сферам) для текущего пользователя.
2.  Реализуй административную функциональность "просмотра от имени": обнови зависимость `get_current_user` для обработки параметра `as_user_id`.
3.  Создай роутер `admin.py` с эндпоинтом `GET /users`, который возвращает список всех пользователей (доступно только админам).

**Этап 5: Финализация и развертывание**
1.  Напиши базовые тесты (например, с помощью `pytest`) для ключевых эндпоинтов, особенно для логики создания записей и проверки прав.
2.  Создай `Dockerfile` и `docker-compose.yml` для запуска приложения вместе с PostgreSQL.
3.  Подготовь файл `.env.example` для переменных окружения (`SECRET_KEY`, `DATABASE_URL` и т.д.).

**Заключение:**
Предоставь мне код, следуя этому плану. Начни с **Этапа 1**. Я ожидаю увидеть работающий, чистый и профессиональный код. Помни, что FastAPI автоматически сгенерирует OpenAPI (Swagger/ReDoc) документацию, которая будет использоваться Flutter-разработчиком, поэтому корректное использование Pydantic-схем и статусов ответа критически важно.